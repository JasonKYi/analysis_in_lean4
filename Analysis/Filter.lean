import Analysis.Set.Function

/--
  A filter on `Œ±` is a set of sets of `Œ±` containing `Œ±` itself, closed under 
  supersets and intersection.
  NB. This definition of filters does not require `‚àÖ ‚àâ sets`. This is done so 
  we can create a lattice structure. `‚àÖ ‚àâ sets` should be included as a 
  seperate proposition in lemmas.
-/
structure Filter (Œ± : Type u) where
  sets                   : Set (Set Œ±)
  univ_sets              : Set.univ ‚àà sets
  sets_of_superset {x y} : x ‚àà sets ‚Üí x ‚äÜ y ‚Üí y ‚àà sets
  inter_sets       {x y} : x ‚àà sets ‚Üí y ‚àà sets ‚Üí x ‚à© y ‚àà sets

-- I'm going to follow 
-- https://web.archive.org/web/20071009170540/http://www.efnet-math.org/~david/mathematics/filters.pdf

-- First, we will find a way to generate filters for any given set of sets of Œ±
-- To achieve this, we consider that the intersection of a collection of filters 
-- is also a filter, so therefore, a filter can be generated form a set of sets 
-- by taking the intersection of all filters containing this set, i.e. if `S` is 
-- type `set (set Œ±)`, then the filter generated by `S` is 
-- ‚ãÇ { F : filter Œ± | S ‚äÜ F.sets }

namespace Filter

open Set

instance : Coe (Filter Œ±) (Set (Set Œ±)) := ‚ü®Œª F => F.sets‚ü©

instance : Mem (Set Œ±) (Filter Œ±) := ‚ü®Œª x F => x ‚àà (F : Set (Set Œ±))‚ü©

/-! ### Basics -/

/-- The intersection of a collection of filters is a filter. -/
def Inf (ùíû : Set (Filter Œ±)) : Filter Œ± :=
{ sets := ‚ãÇ F ‚àà ùíû, F
  univ_sets := Œª F hF => F.univ_sets
  sets_of_superset := Œª hx hxy F hF => F.sets_of_superset (hx F hF) hxy
  inter_sets := Œª hx hy F hF => F.inter_sets (hx F hF) (hy F hF) }

-- With that we can now define the filter generated by an arbitary set of sets 

/-- The filter generated from `S`, a set of sets of `Œ±` is the Inf of all filters 
  containing `S` -/
def generatedFrom (S : Set (Set Œ±)) : Filter Œ± := 
  Inf { F : Filter Œ± | S ‚äÜ (F : Set (Set Œ±)) }

-- The method above generates the smallest filter that contains `S : set (set Œ±)`
-- On the other hand, we can generate a filter using `s : set Œ±` be letting the 
-- filter be all supersets of `s`, this is called `principal s`

/-- The principal filter of a set `s` is set set of all sets larger than `s`. -/
def principal (s : Set Œ±) : Filter Œ± := 
{ sets := { t | s ‚äÜ t }
  univ_sets := Subset.subsetUniv
  sets_of_superset := Œª hx hxy => Subset.trans hx hxy
  inter_sets := Œª hx hy => subsetInter hx hy }

prefix:100 "ùìü " => principal

theorem selfMemPrincipal (s : Set Œ±) : s ‚àà ùìü s := Subset.refl

variable {S : Set (Set Œ±)}

theorem leGeneratedFrom : S ‚äÜ generatedFrom S := 
  Œª s hs F hF => hF _ hs

-- Straightaway, we see that if `‚àÖ ‚àà S`, then `generatedFrom S` is the powerset of `Œ±` 
theorem generatedFromEmpty (hS : ‚àÖ ‚àà S) (s : Set Œ±) : s ‚àà generatedFrom S := 
  (generatedFrom S).sets_of_superset (leGeneratedFrom _ hS) (Subset.empty s)

-- We don't want to consider filters with only the set `univ` and so, we 
-- introduce the `neBot` class

/-- The smallest filter is the filter containing only the set `univ`. -/
def bot : Filter Œ± := 
{ sets := Œª s => univ = s
  univ_sets := rfl
  sets_of_superset := Œª hx hy => Subset.univSubsetIff.1 <| hx ‚ñ∏ hy
  inter_sets := Œª hx hy => Eq.symm <| hx ‚ñ∏ hy ‚ñ∏ interSelf }

/-- A filter is `neBot` if it is not equal to `Filter.bot`-/
class neBot (F : Filter Œ±) where 
  ne_bot : F ‚â† bot

/-- Let `F` be a `ne_bot` filter on `Œ±`, `F` is an ultra filter if for all 
  `S : set Œ±`, `S ‚àà F` or `S·∂ú ‚àà F` -/
class Ultra (F : Filter Œ±) where
  ne_bot : neBot F 
  mem_or_compl_mem {S : Set Œ±} : S ‚àà F ‚à® S·∂ú ‚àà F

-- The ultra filter theorem states that for all `F : filter Œ±`, there exists 
-- some ultra filter `ùïå`, `F ‚äÜ ùïå`.

-- The proof of this follows from Zorn's lemma.
-- Let `F` be a filter on `Œ±`, We have the filters of `Œ±` that contain `F` form 
-- a poset. Let `ùíû` be a chain (a totaly ordered set) within this set, then by 
-- Zorn's lemma, `ùíû` has at least one maximum element. Thus, by checking this 
-- maximum element is indeed an ultra filter, we have found a ultra filter 
-- containing `F`.

-- We won't try proving it anytime soon
-- In Lean 3 mathlib its known as `exists_maximal_of_chains_bounded`

-- theorem existsUltraGe (F : Filter Œ±) [neBot F] : 
--   ‚àÉ (G : Filter Œ±) [Ultra G], (F : Set (Set Œ±)) ‚äÜ G := sorry

/-! ### Convergence -/

/-- Let `F` be a filter and `x : Œ±`. We say `F` tendsto `x` if `ùìü x ‚äÜ F`. -/
def tendstoPointwise (F : Filter Œ±) (x : Œ±) := 
(ùìü (setOf Œª y => y = x) : Set (Set Œ±)) ‚äÜ F

#exit


-- Let X be a Hausdorff space
variables {X : Type*} [topological_space X]

/-- A filter `F` on a Hausdorff space `X` has at most one limit -/
theorem tendsto_unique {x y : X} {F : filter X} [H : ne_bot F] [t2_space X]
  (hFx : tendsto id F (nhds x)) 
  (hFy : tendsto id F (nhds y)) : x = y :=
begin
  by_contra hneq,
  rcases t2_space.t2 _ _ hneq with ‚ü®U, V, hU, hV, hxU, hyV, hdisj‚ü©,
  apply H, rw [‚Üêempty_in_sets_eq_bot, ‚Üêhdisj],
  refine F.inter_sets _ _,
    { rw ‚Üê@preimage_id _ U,
      exact tendsto_def.1 hFx U (mem_nhds_sets hU hxU) },
    { rw ‚Üê@preimage_id _ V,
      exact tendsto_def.1 hFy V (mem_nhds_sets hV hyV) }
end

variables {Y : Type*} [topological_space Y]

@[reducible] def filter_image (f : X ‚Üí Y) (F : filter X) : filter Y := 
  generate $ (Œª s : set X, f '' s) '' F

-- We'll use mathlib's `generate` and `map` which are the same 
-- as the ones we've defined but there is more APIs to work with

/-- A filter `F : filter X` is said to converge to some `x : X` if `nhds x ‚äÜ F` -/
@[reducible] private def converge_to (F : filter X) (x : X) : Prop := 
  (nhds x : set (set X)) ‚äÜ F

-- This definition is equivalent to `tendsto id F (nhds x)`
private lemma converge_to_iff (F : filter X) (x : X) : 
  converge_to F x ‚Üî tendsto id F (nhds x) :=
begin
  refine ‚ü®Œª h, tendsto_def.1 $ Œª s hs, _, Œª h, _‚ü©,
    { rw map_id, simpa using h hs },
    { simp_rw [tendsto_def, preimage_id] at h, exact h }
end

/-- The neighbourhood filter of `x` converges to `x` -/
lemma nhds_tendsto (x : X) : tendsto id (nhds x) (nhds x) := 
Œª U hU, by rwa map_id

lemma mem_filter_image_iff {f : X ‚Üí Y} {F : filter X} (V) : 
  V ‚àà map f F ‚Üî ‚àÉ U ‚àà F, f '' U ‚äÜ V :=
begin
  refine ‚ü®Œª h, ‚ü®_, h, image_preimage_subset _ _‚ü©, Œª h, _‚ü©,
    rcases h with ‚ü®U, hU‚ÇÄ, hU‚ÇÅ‚ü©,
    rw mem_map,
    apply F.sets_of_superset hU‚ÇÄ,
    intros u hu,
    rw mem_set_of_eq,
    apply hU‚ÇÅ, rw mem_image,
    exact ‚ü®u, hu, rfl‚ü©    
end

lemma nhds_subset_filter_of_tendsto {x : X} {F : filter X} 
  (hF : tendsto id F (nhds x)) : (nhds x : set (set X)) ‚äÜ F :=
begin
  intros s hs,
  have := tendsto_def.1 hF _ hs,
  rwa preimage_id at this
end

/-- A map between topological spaces `f : X ‚Üí Y` is continuous at some `x : X` 
  if for all `F : filter X` that tends to `x`, `map F` tends to `f(x)` -/
theorem continuous_of_filter_tendsto {x : X} (f : X ‚Üí Y)
  (hF : ‚àÄ F : filter X, tendsto id F (nhds x) ‚Üí 
    tendsto id (map f F) (nhds (f x))) : continuous_at f x :=
Œª _ hU, tendsto_def.1 (hF _ $ nhds_tendsto x) _ hU

/-- If `f : X ‚Üí Y` is a continuous map between topological spaces, then for all 
  `F : filter X` that tends to `x`, `map F` tends to `f(x)` -/
theorem filter_tendsto_of_continuous {x : X} {F : filter X} (f : X ‚Üí Y) 
  (hf : continuous_at f x) (hF : tendsto id F (nhds x)) : 
  tendsto id (map f F) (nhds (f x)) := 
begin
  rw tendsto_def at *, intros U hU,
  exact nhds_subset_filter_of_tendsto hF (hf hU),
end

/-! ### Product Filters -/

/- Given two filters `F` and `G` on the topological spaces `X` and `Y` respectively, 
  we define the the product filter `F √ó G` as a filter on the product space `X √ó Y` 
  such that 
  `prod F G := F.comap prod.fst ‚äì G.comap prod.snd`
  where `prod.fst = (a, b) ‚Ü¶ a`, `prod.snd = (a, b) ‚Ü¶ b` and 
  `(C : filter Œ≤).comap (f : Œ± ‚Üí Œ≤)` is the filter generated by the set of preimages 
  of sets contained in `C`, i.e. `(C.comap f).sets = generate { f‚Åª¬π(s) | s ‚àà C }`. -/

-- We borrow the notation of product filters from mathlib
localized "infix ` √ó·∂† `:60 := filter.prod" in filter

-- Write some theorems here maybe?
-- TODO : make the natural projection : filter (X √ó Y) ‚Üí filter X


/-! ### Compactness -/

variables {C : Type*} [topological_space C] [compact_space C]
/- In mathlib a compact space is a topological space that satisfy the 
  `is_compact` proposition where 
  `def is_compact (s : set Œ±) := ‚àÄ ‚¶Éf‚¶Ñ [ne_bot f], f ‚â§ ùìü s ‚Üí ‚àÉ a ‚àà s, cluster_pt a f`
  (`cluset_pt a f` means a is a limit point of f) -/




end Filter